name: GlitchWitcher - Semantic Bug Prediction Analysis

on:
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  glitch-witcher-semantic:
    runs-on: ubuntu-latest
    if: contains(github.event.comment.body, 'GlitchWitcher-Semantic')

    steps:
      - name: Parse GlitchWitcher-Semantic Command
        id: parse-command
        uses: actions/github-script@v6
        with:
          script: |
            const body = context.payload.comment?.body ?? '';
            core.info(`Full comment: ${body}`);
            // Look for an explicit PR link in the comment
            const linkMatch = body.match(/https:\/\/github\.com\/[^/]+\/[^/]+\/pull\/\d+/);
            let prLink = null;
            if (linkMatch) {
              prLink = linkMatch[0];
              core.info(`PR link provided: ${prLink}`);
            } else {
              // Allow "GlitchWitcher-Semantic" alone when the comment is on a PR
              const hasCmdOnly = /(^|\s)GlitchWitcher-Semantic\s*$/.test(body);
              if (hasCmdOnly && context.payload.issue?.pull_request) {
                const { owner, repo } = context.repo;
                const prNumber = context.issue.number;
                prLink = `https://github.com/${owner}/${repo}/pull/${prNumber}`;
                core.info(`Using current PR: ${prLink}`);
              } else {
                core.setFailed('ERROR: Invalid GlitchWitcher-Semantic command format or missing PR link');
                return;
              }
            }
            // Extract repo owner/name/number from the PR link
            const m = prLink.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)$/);
            if (!m) {
              core.setFailed(`ERROR: Could not parse repository info from PR link: ${prLink}`);
              return;
            }
            const [, repoOwner, repoName, prNumber] = m;
            const fullRepoName = `${repoOwner}-${repoName}`;
            const repoUrl = `https://github.com/${repoOwner}/${repoName}.git`;
            core.setOutput('repo_owner', repoOwner);
            core.setOutput('repo_name', repoName);
            core.setOutput('pr_number', prNumber);
            core.setOutput('full_repo_name', fullRepoName);
            core.setOutput('pr_link', prLink);
            core.setOutput('repo_url', repoUrl)

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          pip install tensorflow==2.12.0 pandas joblib scipy numpy urllib3 scikit-learn javalang torch keras
          sudo apt-get update
          sudo apt-get install -y cloc git openjdk-11-jdk

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Repository
        run: |
          echo "Setting up repository for semantic analysis..."
          # Ensure we're in the right directory
          pwd
          ls -la
          echo "Checking if data file exists:"
          ls -la data/ || echo "data directory not found"
          if [ -f "data/openj9_metrics.csv" ]; then
            echo "âœ… data/openj9_metrics.csv found!"
            wc -l data/openj9_metrics.csv
          else
            echo "âŒ data/openj9_metrics.csv not found"
          fi

      - name: Check Dataset Availability
        id: check-dataset
        run: |
          echo "Checking local dataset availability..."
          dataset_exists="false"
          model_exists="false"
          
          # Check if local dataset CSV exists
          if [ -f "data/openj9_metrics.csv" ]; then
            echo "Local dataset CSV found: data/openj9_metrics.csv"
            dataset_exists="true"
            dataset_path="data/openj9_metrics.csv"
          else
            echo "Local dataset CSV not found, will generate new one"
            dataset_path=""
          fi
          
          # Check if local model artifacts exist
          if [ -f "seantic_trained_models/repd_model_DA.pkl" ] && \
             [ -f "seantic_trained_models/scaler.pkl" ] && \
             [ -f "seantic_trained_models/training_results.pkl" ]; then
            echo "Local semantic model artifacts found"
            model_exists="true"
            model_path="seantic_trained_models"
          else
            echo "Local semantic model artifacts not found, will train new model"
            model_path=""
          fi
          
          echo "dataset_exists=$dataset_exists" >> $GITHUB_OUTPUT
          echo "model_exists=$model_exists" >> $GITHUB_OUTPUT
          echo "dataset_path=$dataset_path" >> $GITHUB_OUTPUT
          echo "model_path=$model_path" >> $GITHUB_OUTPUT

      - name: Use Local Dataset
        run: |
          echo "Checking local dataset for semantic analysis..."
          if [ -f "data/openj9_metrics.csv" ]; then
            echo "âœ… Using existing local dataset: data/openj9_metrics.csv"
            echo "csv_file_path=data/openj9_metrics.csv" >> $GITHUB_ENV
          else
            echo "âš ï¸ Local dataset not found, creating minimal sample dataset..."
            # Create minimal sample dataset as fallback
            mkdir -p data
            echo "project_name,version,class_name,wmc,rfc,loc,max_cc,avg_cc,cbo,ca,ce,ic,cbm,lcom,lcom3,dit,noc,mfa,npm,dam,moa,cam,amc,bug" > data/openj9_metrics.csv
            echo "openj9,unknown,com.example.TestClass,5,10,68,6,2.8,5,0,0,0,1,10,1.0,0,0,0.0,4,0.6666666666666666,2,0.5,13.6,2" >> data/openj9_metrics.csv
            echo "Created fallback dataset: data/openj9_metrics.csv"
            echo "csv_file_path=data/openj9_metrics.csv" >> $GITHUB_ENV
          fi

      - name: Train Model if Missing
        if: steps.check-dataset.outputs.model_exists == 'false'
        run: |
          echo "Training semantic model using local dataset..."
          # Use local dataset
          dataset_path="data/openj9_metrics.csv"
          echo "Using dataset: $dataset_path"
          
          # Create training script
          echo 'import pandas as pd' > train_semantic_model.py
          echo 'import numpy as np' >> train_semantic_model.py
          echo 'import joblib' >> train_semantic_model.py
          echo 'from sklearn.preprocessing import StandardScaler' >> train_semantic_model.py
          echo 'from sklearn.model_selection import train_test_split' >> train_semantic_model.py
          echo 'from REPD_Impl import REPD' >> train_semantic_model.py
          echo 'from autoencoder_tf2 import AutoEncoder' >> train_semantic_model.py
          echo 'import os' >> train_semantic_model.py
          echo '' >> train_semantic_model.py
          echo 'def train_semantic_model(dataset_path):' >> train_semantic_model.py
          echo '    # Load dataset' >> train_semantic_model.py
          echo '    df = pd.read_csv(dataset_path)' >> train_semantic_model.py
          echo '    # Prepare features' >> train_semantic_model.py
          echo '    feature_columns = ["wmc", "rfc", "loc", "max_cc", "avg_cc", "cbo", "ca", "ce", "ic", "cbm", "lcom", "lcom3", "dit", "noc", "mfa", "npm", "dam", "moa", "cam", "amc"]' >> train_semantic_model.py
          echo '    X = df[feature_columns].fillna(0).values' >> train_semantic_model.py
          echo '    y = df["bug"].values' >> train_semantic_model.py
          echo '    # Scale features' >> train_semantic_model.py
          echo '    scaler = StandardScaler()' >> train_semantic_model.py
          echo '    X_scaled = scaler.fit_transform(X)' >> train_semantic_model.py
          echo '    # Create autoencoder' >> train_semantic_model.py
          echo '    input_dim = X_scaled.shape[1]' >> train_semantic_model.py
          echo '    layers = [input_dim, max(50, input_dim//2), max(25, input_dim//4), max(10, input_dim//8)]' >> train_semantic_model.py
          echo '    autoencoder = AutoEncoder(layers, lr=0.01, epoch=100, batch_size=32)' >> train_semantic_model.py
          echo '    # Train autoencoder' >> train_semantic_model.py
          echo '    autoencoder.fit(X_scaled, print_progress=True)' >> train_semantic_model.py
          echo '    # Create REPD model' >> train_semantic_model.py
          echo '    repd_model = REPD(autoencoder)' >> train_semantic_model.py
          echo '    repd_model.fit(X_scaled, y)' >> train_semantic_model.py
          echo '    # Save models' >> train_semantic_model.py
          echo '    os.makedirs("trained_model", exist_ok=True)' >> train_semantic_model.py
          echo '    joblib.dump(repd_model, "trained_model/repd_model_DA.pkl")' >> train_semantic_model.py
          echo '    joblib.dump(scaler, "trained_model/scaler.pkl")' >> train_semantic_model.py
          echo '    # Save training results' >> train_semantic_model.py
          echo '    training_results = {"feature_columns": feature_columns, "input_dim": input_dim, "layers": layers, "dataset_shape": X.shape}' >> train_semantic_model.py
          echo '    joblib.dump(training_results, "trained_model/training_results.pkl")' >> train_semantic_model.py
          echo '    print("Model training completed successfully")' >> train_semantic_model.py
          echo '    return True' >> train_semantic_model.py
          echo '' >> train_semantic_model.py
          echo 'if __name__ == "__main__":' >> train_semantic_model.py
          echo '    import sys' >> train_semantic_model.py
          echo '    if len(sys.argv) != 2:' >> train_semantic_model.py
          echo '        print("Usage: python train_semantic_model.py <dataset_path>")' >> train_semantic_model.py
          echo '        sys.exit(1)' >> train_semantic_model.py
          echo '    success = train_semantic_model(sys.argv[1])' >> train_semantic_model.py
          echo '    if not success:' >> train_semantic_model.py
          echo '        sys.exit(1)' >> train_semantic_model.py
          
          python3 train_semantic_model.py "$dataset_path"
          if [ ! -d "trained_model" ]; then
            echo "ERROR: Failed to generate trained model"
            exit 1
          fi
          echo "Model training completed successfully"

      - name: Prepare Local Models
        run: |
          echo "Preparing local models for semantic analysis..."
          # Create trained_model directory if it doesn't exist
          mkdir -p trained_model
          
          # Check if local models exist
          models_found="false"
          if [ -f "seantic_trained_models/repd_model_DA.pkl" ]; then
            echo "Copying local REPD model..."
            cp seantic_trained_models/repd_model_DA.pkl trained_model/
            models_found="true"
          fi
          
          if [ -f "seantic_trained_models/scaler.pkl" ]; then
            echo "Copying local scaler..."
            cp seantic_trained_models/scaler.pkl trained_model/
            models_found="true"
          fi
          
          if [ -f "seantic_trained_models/training_results.pkl" ]; then
            echo "Copying local training results..."
            cp seantic_trained_models/training_results.pkl trained_model/
            models_found="true"
          fi
          
          if [ "$models_found" = "false" ]; then
            echo "No local models found, will train new models during analysis..."
          else
            echo "Local models prepared successfully"
          fi

      - name: Run Semantic Analysis on Target PR
        id: analysis
        run: |
          set -e
          echo "Running GlitchWitcher semantic analysis on ${{ steps.parse-command.outputs.pr_link }}..."
          
          # Get PR details using GitHub API
          pr_api_url="https://api.github.com/repos/${{ steps.parse-command.outputs.repo_owner }}/${{ steps.parse-command.outputs.repo_name }}/pulls/${{ steps.parse-command.outputs.pr_number }}"
          pr_info=$(curl -s -H "Accept: application/vnd.github.v3+json" "$pr_api_url")
          # Parse base/head SHAs using Python (more robust than grep)
          base_sha=$(printf "%s" "$pr_info" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d['base']['sha'])")
          head_sha=$(printf "%s" "$pr_info" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d['head']['sha'])")
          echo "Base SHA: $base_sha"
          echo "Head SHA: $head_sha"
          
          # Clone the target repository
          git clone "${{ steps.parse-command.outputs.repo_url }}" target_repo
          # Ensure we have the PR head commit (works for forks)
          git -C target_repo fetch origin "pull/${{ steps.parse-command.outputs.pr_number }}/head:prhead" || true
          git -C target_repo fetch --all --tags --prune
          
          # Get changed files between base..head (Java only)
          merge_base=$(git -C target_repo merge-base "$base_sha" "$head_sha")
          echo "Merge base: $merge_base"
          changed_files=$(git -C target_repo diff --name-only "$merge_base" "$head_sha" | grep -E "\.java$" || true)
          if [ -z "$changed_files" ]; then
            echo "No Java files changed in this PR"
            echo "comment=No Java files found in the PR changes." >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Changed files:"
          printf "%s\n" "$changed_files"
          
          # Extract semantic features for base commit
          git -C target_repo checkout "$base_sha"
          mkdir -p metrics_output_base
          echo "project_name,version,class_name,wmc,rfc,loc,max_cc,avg_cc,cbo,ca,ce,ic,cbm,lcom,lcom3,dit,noc,mfa,npm,dam,moa,cam,amc,bug" > metrics_output_base/summary_metrics.csv
          
          for file in $changed_files; do
            fpath="target_repo/$file"
            if [ -f "$fpath" ]; then
              echo "Processing $file (base)..."
              # Use the separate Java analysis script
              python3 analyze_java_file.py "$fpath" "${{ steps.parse-command.outputs.repo_name }}" "unknown" "target_repo"
              if [ -f "temp_metrics.csv" ]; then
                tail -n +2 "temp_metrics.csv" >> metrics_output_base/summary_metrics.csv
                rm "temp_metrics.csv"
              fi
            else
              echo "Warning: File not found at $fpath (base)."
            fi
          done
          
          # Extract semantic features for head commit
          git -C target_repo checkout "$head_sha"
          mkdir -p metrics_output_head
          echo "project_name,version,class_name,wmc,rfc,loc,max_cc,avg_cc,cbo,ca,ce,ic,cbm,lcom,lcom3,dit,noc,mfa,npm,dam,moa,cam,amc,bug" > metrics_output_head/summary_metrics.csv
          
          for file in $changed_files; do
            fpath="target_repo/$file"
            if [ -f "$fpath" ]; then
              echo "Processing $file (head)..."
              # Use the separate Java analysis script
              python3 analyze_java_file.py "$fpath" "${{ steps.parse-command.outputs.repo_name }}" "unknown" "target_repo"
              if [ -f "temp_metrics.csv" ]; then
                tail -n +2 "temp_metrics.csv" >> metrics_output_head/summary_metrics.csv
                rm "temp_metrics.csv"
              fi
            else
              echo "Warning: File not found at $fpath (head)."
            fi
          done
          
          echo "=== Row counts ==="
          echo "Base rows: $(wc -l < metrics_output_base/summary_metrics.csv || echo 0)"
          echo "Head rows: $(wc -l < metrics_output_head/summary_metrics.csv || echo 0)"
          
          # Prepare trained model: Use local models
          have_model="false"
          if [ -d "trained_model" ] && [ -f "trained_model/repd_model_DA.pkl" ]; then
            echo "Using local semantic model artifacts..."
            have_model="true"
          else
            echo "Local models not found, training new model..."
            # Train a new model using the available dataset
            dataset_path="data/openj9_metrics.csv"
            if [ -f "$dataset_path" ]; then
              echo "Training model with dataset: $dataset_path"
              python3 train_semantic_model.py "$dataset_path"
              if [ -d "trained_model" ] && [ -f "trained_model/repd_model_DA.pkl" ]; then
                echo "Model training completed successfully"
                have_model="true"
              else
                echo "Model training failed"
              fi
            else
              echo "No dataset available for training"
            fi
          fi
          
          if [ "$have_model" != "true" ]; then
            echo "comment=Unable to train or find semantic model for predictions." >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create the comparison script
          echo 'import sys' > compare_semantic_predictions.py
          echo 'import os' >> compare_semantic_predictions.py
          echo 'import pandas as pd' >> compare_semantic_predictions.py
          echo 'import numpy as np' >> compare_semantic_predictions.py
          echo 'import joblib' >> compare_semantic_predictions.py
          echo 'from REPD_Impl import REPD' >> compare_semantic_predictions.py
          echo 'from autoencoder_tf2 import AutoEncoder' >> compare_semantic_predictions.py
          echo '' >> compare_semantic_predictions.py
          echo 'def predict_semantic(csv_file, model_dir):' >> compare_semantic_predictions.py
          echo '    # Load dataset' >> compare_semantic_predictions.py
          echo '    df = pd.read_csv(csv_file)' >> compare_semantic_predictions.py
          echo '    # Load model and scaler' >> compare_semantic_predictions.py
          echo '    repd_model = joblib.load(f"{model_dir}/repd_model_DA.pkl")' >> compare_semantic_predictions.py
          echo '    scaler = joblib.load(f"{model_dir}/scaler.pkl")' >> compare_semantic_predictions.py
          echo '    training_results = joblib.load(f"{model_dir}/training_results.pkl")' >> compare_semantic_predictions.py
          echo '    # Prepare features' >> compare_semantic_predictions.py
          echo '    feature_columns = training_results["feature_columns"]' >> compare_semantic_predictions.py
          echo '    X = df[feature_columns].fillna(0).values' >> compare_semantic_predictions.py
          echo '    X_scaled = scaler.transform(X)' >> compare_semantic_predictions.py
          echo '    # Get predictions' >> compare_semantic_predictions.py
          echo '    predictions = repd_model.predict(X_scaled)' >> compare_semantic_predictions.py
          echo '    # Get probability densities' >> compare_semantic_predictions.py
          echo '    test_errors = repd_model.calculate_reconstruction_error(X_scaled)' >> compare_semantic_predictions.py
          echo '    p_nd = repd_model.get_non_defect_probability(test_errors)' >> compare_semantic_predictions.py
          echo '    p_d = repd_model.get_defect_probability(test_errors)' >> compare_semantic_predictions.py
          echo '    results = []' >> compare_semantic_predictions.py
          echo '    for i, (_, row) in enumerate(df.iterrows()):' >> compare_semantic_predictions.py
          echo '        results.append({"file": row["class_name"], "p_defective": p_d[i], "p_non_defective": p_nd[i]})' >> compare_semantic_predictions.py
          echo '    return results' >> compare_semantic_predictions.py
          echo '' >> compare_semantic_predictions.py
          echo 'def format_results_for_comparison(file_names, base_data, head_data):' >> compare_semantic_predictions.py
          echo '    output = []' >> compare_semantic_predictions.py
          echo '    output.append("### ðŸ“Š **Semantic Analysis Results**")' >> compare_semantic_predictions.py
          echo '    output.append("")' >> compare_semantic_predictions.py
          echo '    output.append("| File | Base (Non-Defective) | Base (Defective) | Head (Non-Defective) | Head (Defective) | Risk Change |")' >> compare_semantic_predictions.py
          echo '    output.append("|------|---------------------|------------------|---------------------|------------------|-------------|")' >> compare_semantic_predictions.py
          echo '    for i, file_name in enumerate(file_names):' >> compare_semantic_predictions.py
          echo '        if i < len(base_data) and i < len(head_data):' >> compare_semantic_predictions.py
          echo '            base_nd = base_data[i]["p_non_defective"]' >> compare_semantic_predictions.py
          echo '            base_d = base_data[i]["p_defective"]' >> compare_semantic_predictions.py
          echo '            head_nd = head_data[i]["p_non_defective"]' >> compare_semantic_predictions.py
          echo '            head_d = head_data[i]["p_defective"]' >> compare_semantic_predictions.py
          echo '            base_risk = "ðŸŸ¢ Low" if base_nd > base_d else "ðŸ”´ High"' >> compare_semantic_predictions.py
          echo '            head_risk = "ðŸŸ¢ Low" if head_nd > head_d else "ðŸ”´ High"' >> compare_semantic_predictions.py
          echo '            risk_change = "âž¡ï¸ Same" if base_risk == head_risk else ("â¬†ï¸ Increased" if head_risk == "ðŸ”´ High" else "â¬‡ï¸ Decreased")' >> compare_semantic_predictions.py
          echo '            output.append(f"| {file_name} | {base_nd:.6f} | {base_d:.6f} | {head_nd:.6f} | {head_d:.6f} | {risk_change} |")' >> compare_semantic_predictions.py
          echo '    return "\\n".join(output)' >> compare_semantic_predictions.py
          echo '' >> compare_semantic_predictions.py
          echo '# Run comparison' >> compare_semantic_predictions.py
          echo 'base_results = predict_semantic("metrics_output_base/summary_metrics.csv", "trained_model")' >> compare_semantic_predictions.py
          echo 'head_results = predict_semantic("metrics_output_head/summary_metrics.csv", "trained_model")' >> compare_semantic_predictions.py
          echo 'file_names = [r["file"] for r in base_results]' >> compare_semantic_predictions.py
          echo 'base_data = [{"p_defective": r["p_defective"], "p_non_defective": r["p_non_defective"]} for r in base_results]' >> compare_semantic_predictions.py
          echo 'head_data = [{"p_defective": r["p_defective"], "p_non_defective": r["p_non_defective"]} for r in head_results]' >> compare_semantic_predictions.py
          echo 'comparison_output = format_results_for_comparison(file_names, base_data, head_data)' >> compare_semantic_predictions.py
          echo 'print(comparison_output)' >> compare_semantic_predictions.py
          
          echo "Running semantic comparison predictions..."
          if [ -f "metrics_output_base/summary_metrics.csv" ] && [ -f "metrics_output_head/summary_metrics.csv" ]; then
            comparison_result=$(python3 compare_semantic_predictions.py)
            if [ -n "$comparison_result" ]; then
              echo "comment=$comparison_result" >> $GITHUB_OUTPUT
              echo "" >> $GITHUB_OUTPUT
              echo "### ðŸ“‹ Semantic Analysis Interpretation:" >> $GITHUB_OUTPUT
              echo "> This analysis uses **semantic features** extracted from Java AST (Abstract Syntax Tree) including:" >> $GITHUB_OUTPUT
              echo "> - **WMC (Weighted Methods per Class)**: Complexity of class methods" >> $GITHUB_OUTPUT
              echo "> - **RFC (Response for Class)**: Number of methods that can be executed" >> $GITHUB_OUTPUT
              echo "> - **LCOM (Lack of Cohesion of Methods)**: Measure of class cohesion" >> $GITHUB_OUTPUT
              echo "> - **CBO (Coupling Between Objects)**: Degree of coupling between classes" >> $GITHUB_OUTPUT
              echo "> - **DIT (Depth of Inheritance Tree)**: Inheritance depth" >> $GITHUB_OUTPUT
              echo "> - **NOC (Number of Children)**: Number of direct subclasses" >> $GITHUB_OUTPUT
              echo "> - **CAM (Cohesion Among Methods)**: Method parameter similarity" >> $GITHUB_OUTPUT
              echo "" >> $GITHUB_OUTPUT
              echo "> The values shown are **Probability Densities (PDFs)**, not probabilities. Higher values indicate better fit for that category." >> $GITHUB_OUTPUT
            else
              echo "comment=Semantic comparison prediction produced no output." >> $GITHUB_OUTPUT
            fi
          else
            echo "comment=Missing base or head metrics files for semantic comparison." >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR
        if: steps.analysis.outputs.comment != ''
        uses: actions/github-script@v6
        env:
          COMMENT_BODY: "${{ steps.analysis.outputs.comment }}"
          PR_LINK: "${{ steps.parse-command.outputs.pr_link }}"
          REPO_NAME: "${{ steps.parse-command.outputs.full_repo_name }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentBody = `## ðŸ”® GlitchWitcher Semantic Analysis Results
            **Target PR:** ${process.env.PR_LINK}
            **Repository:** ${process.env.REPO_NAME}
            ${process.env.COMMENT_BODY}
            *Semantic analysis performed by GlitchWitcher Bot using AST-based features*`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            }); 
